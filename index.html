<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Tracker</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* Simple body style to match the theme */
        body {
            background-color: #111827; /* bg-gray-900 */
        }
        .dragging {
            opacity: 0.5;
        }
        .world-map-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { 
            getAuth, 
            onAuthStateChanged, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut 
        } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            addDoc, 
            query, 
            where, 
            getDocs,
            doc,
            updateDoc,
            writeBatch,
            deleteDoc
        } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        const { useState, useEffect, useMemo, useRef } = React;

        // --- IMPORTANT ---
        // Your web app's Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyCWiDK8pm24MEKDC8DmcR68VwgWKx2j5eM",
          authDomain: "book-tracker-v2.firebaseapp.com",
          projectId: "book-tracker-v2",
          storageBucket: "book-tracker-v2.appspot.com",
          messagingSenderId: "148759504044",
          appId: "1:148759504044:web:5332ca5553a0cd2a92ab09"
        };

        // Your Google Books API Key
        const GOOGLE_BOOKS_API_KEY = 'AIzaSyDEzTQ4nm3Hw8iPnW8ZRKYsCcYCG_oJwb4';

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Helper Functions ---
        const parseGenre = (categories) => {
            if (!categories || categories.length === 0) return 'General';
            
            const forbiddenTerms = ['fiction', 'non-fiction', 'general', 'biography & autobiography', 'comics & graphic novels', 'books'];
            let potentialGenres = [];

            for (const category of categories) {
                const parts = category.split(/ \/ | > /);
                for (const part of parts) {
                    const cleanPart = part.trim();
                    if (cleanPart && !forbiddenTerms.includes(cleanPart.toLowerCase())) {
                        potentialGenres.push(cleanPart);
                    }
                }
            }
            
            return potentialGenres.length > 0 ? potentialGenres[potentialGenres.length - 1] : 'General';
        };
        
        const isNonFiction = (categories) => {
            if (!categories || categories.length === 0) return false;
            const nonFictionKeywords = ['biography', 'autobiography', 'history', 'science', 'business', 'psychology', 'self-help', 'memoir', 'true crime', 'nonfiction'];
            const categoryString = categories.join(' ').toLowerCase();
            return nonFictionKeywords.some(keyword => categoryString.includes(keyword));
        };


        const sanitizeIsbn = (isbn) => {
            return isbn.replace(/[-\s]/g, '');
        };

        // --- Main App Component ---
        function App() {
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    setUser(user);
                    setLoading(false);
                });
                return () => unsubscribe();
            }, []);

            if (loading) {
                return <div className="flex items-center justify-center h-screen bg-gray-900 text-white">Loading...</div>;
            }

            return (
                <div className="min-h-screen bg-gray-900 text-gray-100 font-sans">
                    {user ? <Dashboard user={user} /> : <Login />}
                </div>
            );
        }

        // --- Login/Signup Component ---
        function Login() {
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');
            const [isSignUp, setIsSignUp] = useState(false);

            const handleAuth = async (e) => {
                e.preventDefault();
                setError('');
                try {
                    if (isSignUp) {
                        await createUserWithEmailAndPassword(auth, email, password);
                    } else {
                        await signInWithEmailAndPassword(auth, email, password);
                    }
                } catch (err) {
                    setError(err.message);
                }
            };

            return (
                <div className="flex items-center justify-center h-screen">
                    <div className="w-full max-w-md p-8 space-y-6 bg-gray-800 rounded-lg shadow-lg">
                        <h2 className="text-2xl font-bold text-center text-white">{isSignUp ? 'Create Account' : 'Welcome Back'}</h2>
                        <form onSubmit={handleAuth} className="space-y-6">
                            <div>
                                <label className="text-sm font-bold text-gray-400">Email</label>
                                <input
                                    type="email"
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    className="w-full p-3 mt-1 text-gray-200 bg-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                    required
                                />
                            </div>
                            <div>
                                <label className="text-sm font-bold text-gray-400">Password</label>
                                <input
                                    type="password"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    className="w-full p-3 mt-1 text-gray-200 bg-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                    required
                                />
                            </div>
                            {error && <p className="text-sm text-red-400">{error}</p>}
                            <button type="submit" className="w-full py-3 font-bold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 transition duration-300">
                                {isSignUp ? 'Sign Up' : 'Login'}
                            </button>
                        </form>
                        <p className="text-sm text-center text-gray-400">
                            {isSignUp ? 'Already have an account?' : "Don't have an account?"}
                            <button onClick={() => setIsSignUp(!isSignUp)} className="ml-1 font-bold text-indigo-400 hover:underline">
                                {isSignUp ? 'Login' : 'Sign Up'}
                            </button>
                        </p>
                    </div>
                </div>
            );
        }

        // --- Main Dashboard Component ---
        function Dashboard({ user }) {
            const [view, setView] = useState('gallery');
            const [books, setBooks] = useState([]);
            const [loadingBooks, setLoadingBooks] = useState(true);

            const fetchBooks = async () => {
                setLoadingBooks(true);
                const q = query(collection(db, "readings"), where("userId", "==", user.uid));
                const querySnapshot = await getDocs(q);
                const userBooks = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                // Sort by custom order first, then by date for books without an order
                userBooks.sort((a, b) => (a.orderIndex ?? Infinity) - (b.orderIndex ?? Infinity) || new Date(a.readDate) - new Date(b.readDate));
                setBooks(userBooks);
                setLoadingBooks(false);
            };

            useEffect(() => {
                fetchBooks();
            }, [user]);

            const handleBooksChanged = () => {
                fetchBooks();
                setView('gallery');
            };

            return (
                <div className="p-4 md:p-8">
                    <Navbar user={user} setView={setView} currentView={view} />
                    <main className="mt-8">
                        {view === 'add-single' && <AddBook books={books} onBookAdded={handleBooksChanged} onCancel={() => setView('gallery')} />}
                        {view === 'add-multiple' && <AddMultipleBooks books={books} onBooksAdded={handleBooksChanged} onCancel={() => setView('gallery')} />}
                        {view === 'stats' && <Stats books={books} loading={loadingBooks} />}
                        {view === 'gallery' && <BooksDisplay books={books} loading={loadingBooks} onBookUpdated={fetchBooks} />}
                        {view === 'search' && <Search books={books} onCancel={() => setView('gallery')} />}
                    </main>
                </div>
            );
        }

        // --- Navbar Component ---
        function Navbar({ user, setView, currentView }) {
            const activeClass = "bg-indigo-600 text-white";
            const inactiveClass = "text-gray-300 hover:bg-gray-700 hover:text-white";

            return (
                <header className="flex flex-col md:flex-row justify-between items-center">
                    <div className="flex items-baseline gap-2 mb-4 md:mb-0">
                        <h1 className="text-3xl font-bold text-white">Book Tracker</h1>
                        <span className="font-mono text-xs text-gray-500">v0.52</span>
                    </div>
                    <nav className="flex items-center space-x-2 bg-gray-800 p-2 rounded-lg">
                        <button onClick={() => setView('gallery')} className={`px-3 py-2 rounded-md text-sm font-medium ${currentView === 'gallery' ? activeClass : inactiveClass}`}>Books</button>
                        <button onClick={() => setView('stats')} className={`px-3 py-2 rounded-md text-sm font-medium ${currentView === 'stats' ? activeClass : inactiveClass}`}>Stats</button>
                        <button onClick={() => setView('search')} className={`px-3 py-2 rounded-md text-sm font-medium ${currentView === 'search' ? activeClass : inactiveClass}`}>Search</button>
                        <button onClick={() => setView('add-single')} className={`px-3 py-2 rounded-md text-sm font-medium ${currentView === 'add-single' ? activeClass : inactiveClass}`}>+ Add Book</button>
                        <button onClick={() => setView('add-multiple')} className={`px-3 py-2 rounded-md text-sm font-medium ${currentView === 'add-multiple' ? activeClass : inactiveClass}`}>+ Add Multiple</button>
                    </nav>
                    <div className="hidden md:flex items-center space-x-4">
                        <span className="text-sm text-gray-400">{user.email}</span>
                        <button onClick={() => signOut(auth)} className="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700">Logout</button>
                    </div>
                </header>
            );
        }

        // --- Add Single Book Component ---
        function AddBook({ books, onBookAdded, onCancel }) {
            const [isbn, setIsbn] = useState('');
            const [bookData, setBookData] = useState(null);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            const [readMonth, setReadMonth] = useState(new Date().getMonth());
            const [readYear, setReadYear] = useState(new Date().getFullYear());
            const [isAddingNewGenre, setIsAddingNewGenre] = useState(false);
            const [isManualAdd, setIsManualAdd] = useState(false);
            const [manualFormData, setManualFormData] = useState({
                title: '',
                author: '',
                isFiction: true,
                genre: '',
                pageCount: 0,
                coverUrl: '',
                country: '',
            });

            const fictionGenres = useMemo(() => [...new Set(books.filter(b => b.isFiction).map(b => b.genre))], [books]);
            const nonFictionGenres = useMemo(() => [...new Set(books.filter(b => !b.isFiction).map(b => b.genre))], [books]);

            const handleIsbnSearch = async (e) => {
                e.preventDefault();
                setLoading(true);
                setError('');
                setBookData(null);
                setIsManualAdd(false);
                try {
                    const sanitized = sanitizeIsbn(isbn);
                    const url = `https://www.googleapis.com/books/v1/volumes?q=isbn:${sanitized}${GOOGLE_BOOKS_API_KEY ? '&key=' + GOOGLE_BOOKS_API_KEY : ''}`;
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.totalItems > 0) {
                        const book = data.items[0].volumeInfo;
                        setBookData({
                            title: book.title || 'N/A',
                            author: book.authors ? book.authors.join(', ') : 'N/A',
                            isFiction: !isNonFiction(book.categories),
                            genre: parseGenre(book.categories),
                            pageCount: book.pageCount || 0,
                            publicationYear: book.publishedDate ? new Date(book.publishedDate).getFullYear() : 'N/A',
                            coverUrl: book.imageLinks?.thumbnail || `https://placehold.co/128x192/1f2937/ffffff?text=${book.title.split(' ').join('+')}`,
                            country: '',
                        });
                    } else {
                        setError('Book not found for this ISBN.');
                    }
                } catch (err) {
                    setError('Failed to fetch book data. Please check the ISBN and your connection.');
                }
                setLoading(false);
            };

            const handleAddBook = async (e) => {
                e.preventDefault();
                if (!bookData) return;
                
                const readDate = new Date(readYear, readMonth, 15).toISOString().split('T')[0];
                const bookToAdd = {
                    ...bookData,
                    isbn: sanitizeIsbn(isbn),
                    readDate,
                    readYear: Number(readYear),
                    userId: auth.currentUser.uid,
                    orderIndex: Date.now(),
                };

                try {
                    await addDoc(collection(db, "readings"), bookToAdd);
                    setIsbn('');
                    setBookData(null);
                    setReadMonth(new Date().getMonth());
                    setReadYear(new Date().getFullYear());
                    onBookAdded();
                } catch (err) {
                    setError('Failed to save book to your library.');
                }
            };

            const handleSaveManualBook = async (e) => {
                e.preventDefault();
                if (!manualFormData.title || !manualFormData.author) {
                    setError('Title and Author are required.');
                    return;
                }
                
                const readDate = new Date(readYear, readMonth, 15).toISOString().split('T')[0];
                const bookToAdd = {
                    ...manualFormData,
                    pageCount: Number(manualFormData.pageCount) || 0,
                    coverUrl: manualFormData.coverUrl || `https://placehold.co/128x192/1f2937/ffffff?text=${manualFormData.title.split(' ').join('+')}`,
                    readDate,
                    readYear: Number(readYear),
                    userId: auth.currentUser.uid,
                    orderIndex: Date.now(),
                    isbn: '', // No ISBN for manual entries
                };

                try {
                    await addDoc(collection(db, "readings"), bookToAdd);
                    setIsManualAdd(false);
                    setManualFormData({ title: '', author: '', isFiction: true, genre: '', pageCount: 0, coverUrl: '', country: '' });
                    setReadMonth(new Date().getMonth());
                    setReadYear(new Date().getFullYear());
                    onBookAdded();
                } catch (err) {
                    setError('Failed to save book to your library.');
                }
            };
            
            const handleBookDataChange = (e) => {
                const { name, value } = e.target;
                if (name === 'genreSelect') {
                    if (value === 'add-new') {
                        setIsAddingNewGenre(true);
                        setBookData(prev => ({ ...prev, genre: '' }));
                    } else {
                        setIsAddingNewGenre(false);
                        setBookData(prev => ({ ...prev, genre: value }));
                    }
                } else {
                    setBookData(prev => ({ ...prev, [name]: value }));
                }
            };

            const handleManualFormChange = (e) => {
                const { name, value } = e.target;

                if (name === 'genreSelect') {
                    if (value === 'add-new') {
                        setIsAddingNewGenre(true);
                        setManualFormData(prev => ({ ...prev, genre: '' }));
                    } else {
                        setIsAddingNewGenre(false);
                        setManualFormData(prev => ({ ...prev, genre: value }));
                    }
                } else if (name === 'isFiction') {
                    const isFictionValue = value === 'true';
                    setManualFormData(prev => ({ 
                        ...prev, 
                        isFiction: isFictionValue,
                        genre: (isFictionValue ? fictionGenres : nonFictionGenres).includes(prev.genre) ? prev.genre : ''
                    }));
                } else {
                    setManualFormData(prev => ({ ...prev, [name]: value }));
                }
            };

            const handleToggleManualAdd = () => {
                setIsManualAdd(true);
                setError(''); // Clear the "not found" error
            };

            return (
                <div className="max-w-2xl mx-auto p-6 bg-gray-800 rounded-lg">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-xl font-bold">{isManualAdd ? 'Add Book Manually' : 'Add a New Book'}</h2>
                        <button onClick={onCancel} className="text-gray-400 hover:text-white">&times;</button>
                    </div>

                    {!isManualAdd && (
                        <form onSubmit={handleIsbnSearch} className="flex gap-2 mb-4">
                            <input
                                type="text"
                                value={isbn}
                                onChange={(e) => setIsbn(e.target.value)}
                                placeholder="Enter 10 or 13-digit ISBN"
                                className="flex-grow p-2 bg-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                            />
                            <button type="submit" disabled={loading} className="px-4 py-2 font-bold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 disabled:bg-gray-500">
                                {loading ? 'Searching...' : 'Find Book'}
                            </button>
                        </form>
                    )}

                    {error && <p className="text-red-400 mb-4">{error}</p>}

                    {error === 'Book not found for this ISBN.' && !bookData && !isManualAdd && (
                        <div className="text-center">
                            <button onClick={handleToggleManualAdd} className="px-4 py-2 font-bold text-white bg-green-600 rounded-md hover:bg-green-700">
                                Add Manually
                            </button>
                        </div>
                    )}

                    {isManualAdd && (
                         <form onSubmit={handleSaveManualBook} className="space-y-4">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-400">Title*</label>
                                    <input type="text" name="title" value={manualFormData.title} onChange={handleManualFormChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white" required/>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-400">Author*</label>
                                    <input type="text" name="author" value={manualFormData.author} onChange={handleManualFormChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white" required/>
                                </div>
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-400">Cover Image URL</label>
                                <input type="text" name="coverUrl" value={manualFormData.coverUrl} onChange={handleManualFormChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white"/>
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-400">Date Read</label>
                                <div className="flex gap-2 mt-1">
                                    <select value={readMonth} onChange={e => setReadMonth(parseInt(e.target.value))} className="w-full p-2 bg-gray-700 rounded-md text-white">
                                        {['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map((m, i) => <option key={i} value={i}>{m}</option>)}
                                    </select>
                                    <input type="number" value={readYear} onChange={e => setReadYear(parseInt(e.target.value))} className="w-full p-2 bg-gray-700 rounded-md text-white" />
                                </div>
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-400">Type</label>
                                    <select name="isFiction" value={manualFormData.isFiction} onChange={handleManualFormChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white">
                                        <option value="true">Fiction</option>
                                        <option value="false">Non-Fiction</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-400">Pages</label>
                                    <input type="number" name="pageCount" value={manualFormData.pageCount} onChange={handleManualFormChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white"/>
                                </div>
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-400">Genre</label>
                                <select name="genreSelect" value={isAddingNewGenre ? 'add-new' : manualFormData.genre} onChange={handleManualFormChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white">
                                    <option value="" disabled>Select a genre</option>
                                    {(manualFormData.isFiction ? fictionGenres : nonFictionGenres).map(g => <option key={g} value={g}>{g}</option>)}
                                    <option value="add-new">--- Add New Genre ---</option>
                                </select>
                                {isAddingNewGenre && (
                                    <input type="text" name="genre" placeholder="New Genre" value={manualFormData.genre} onChange={handleManualFormChange} className="w-full p-2 mt-2 bg-gray-600 rounded-md text-white"/>
                                )}
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-400">Author's Country</label>
                                <input type="text" name="country" value={manualFormData.country} onChange={handleManualFormChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white"/>
                            </div>
                            <button type="submit" className="w-full py-3 font-bold text-white bg-green-600 rounded-md hover:bg-green-700">Add to Library</button>
                        </form>
                    )}

                    {bookData && !isManualAdd && (
                        <form onSubmit={handleAddBook}>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-6 pt-4">
                                <div className="md:col-span-1">
                                    <img src={bookData.coverUrl} alt={bookData.title} className="w-full h-auto object-cover rounded-md shadow-lg" />
                                </div>
                                <div className="md:col-span-2 space-y-4">
                                    <h3 className="text-2xl font-bold">{bookData.title}</h3>
                                    <p className="text-gray-400">by {bookData.author}</p>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-400">Date Read</label>
                                        <div className="flex gap-2 mt-1">
                                            <select value={readMonth} onChange={e => setReadMonth(parseInt(e.target.value))} className="w-full p-2 bg-gray-700 rounded-md text-white">
                                                {['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map((m, i) => <option key={i} value={i}>{m}</option>)}
                                            </select>
                                            <input type="number" value={readYear} onChange={e => setReadYear(parseInt(e.target.value))} className="w-full p-2 bg-gray-700 rounded-md text-white" />
                                        </div>
                                    </div>
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm font-medium text-gray-400">Type</label>
                                            <select name="isFiction" value={bookData.isFiction} onChange={e => handleBookDataChange({ target: { name: 'isFiction', value: e.target.value === 'true' }})} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white">
                                                <option value="true">Fiction</option>
                                                <option value="false">Non-Fiction</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium text-gray-400">Pages</label>
                                            <input type="number" name="pageCount" value={bookData.pageCount} onChange={handleBookDataChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white"/>
                                        </div>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-400">Genre</label>
                                        <select name="genreSelect" value={isAddingNewGenre ? 'add-new' : bookData.genre} onChange={handleBookDataChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white">
                                            <option value={bookData.genre} disabled>{bookData.genre}</option>
                                            {(bookData.isFiction ? fictionGenres : nonFictionGenres).map(g => <option key={g} value={g}>{g}</option>)}
                                            <option value="add-new">--- Add New Genre ---</option>
                                        </select>
                                        {isAddingNewGenre && (
                                            <input type="text" name="genre" placeholder="New Genre" value={bookData.genre} onChange={handleBookDataChange} className="w-full p-2 mt-2 bg-gray-600 rounded-md text-white"/>
                                        )}
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-400">Author's Country</label>
                                        <input type="text" name="country" value={bookData.country} onChange={handleBookDataChange} className="w-full p-2 mt-1 bg-gray-700 rounded-md text-white"/>
                                    </div>
                                    <button type="submit" className="w-full py-3 font-bold text-white bg-green-600 rounded-md hover:bg-green-700">Add to Library</button>
                                </div>
                            </div>
                        </form>
                    )}
                </div>
            );
        }

        // --- Add Multiple Books Component ---
        function AddMultipleBooks({ books, onBooksAdded, onCancel }) {
            const [isbnList, setIsbnList] = useState('');
            const [foundBooks, setFoundBooks] = useState([]);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');

            const fictionGenres = useMemo(() => [...new Set(books.filter(b => b.isFiction).map(b => b.genre))], [books]);
            const nonFictionGenres = useMemo(() => [...new Set(books.filter(b => !b.isFiction).map(b => b.genre))], [books]);

            const handlePaste = (e) => {
                e.preventDefault();
                const pastedText = e.clipboardData.getData('text').trim();
                if (!pastedText) return;

                const separator = isbnList.trim() === '' ? '' : ', ';
                setIsbnList(prevList => prevList + separator + pastedText);
            };

            const handleFindBooks = async (e) => {
                e.preventDefault();
                setLoading(true);
                setError('');
                setFoundBooks([]);
                
                const isbns = isbnList.split(/[\s,]+/).filter(isbn => isbn.trim() !== '');
                if (isbns.length === 0) {
                    setError('Please enter at least one ISBN.');
                    setLoading(false);
                    return;
                }

                try {
                    const bookPromises = isbns.map(async rawIsbn => {
                        const isbn = sanitizeIsbn(rawIsbn);
                        const url = `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}${GOOGLE_BOOKS_API_KEY ? '&key=' + GOOGLE_BOOKS_API_KEY : ''}`;
                        const response = await fetch(url);
                        const data = await response.json();
                        if (data.totalItems > 0) {
                            const book = data.items[0].volumeInfo;
                            return {
                                isbn,
                                title: book.title || 'N/A',
                                author: book.authors ? book.authors.join(', ') : 'N/A',
                                isFiction: !isNonFiction(book.categories),
                                genre: parseGenre(book.categories),
                                pageCount: book.pageCount || 0,
                                publicationYear: book.publishedDate ? new Date(book.publishedDate).getFullYear() : 'N/A',
                                coverUrl: book.imageLinks?.thumbnail || `https://placehold.co/128x192/1f2937/ffffff?text=${book.title.split(' ').join('+')}`,
                                readMonth: new Date().getMonth(),
                                readYear: new Date().getFullYear(),
                                country: '',
                            };
                        }
                        return { isbn: rawIsbn, error: 'Not Found' };
                    });

                    const results = await Promise.all(bookPromises);
                    setFoundBooks(results.map(b => ({...b, isAddingNewGenre: false })));

                } catch (err) {
                    setError('An error occurred while fetching book data.');
                }
                setLoading(false);
            };

            const handleBookDataChange = (index, field, value) => {
                const updatedBooks = [...foundBooks];
                if (field === 'genreSelect') {
                    if (value === 'add-new') {
                        updatedBooks[index].isAddingNewGenre = true;
                        updatedBooks[index].genre = '';
                    } else {
                        updatedBooks[index].isAddingNewGenre = false;
                        updatedBooks[index].genre = value;
                    }
                } else {
                    updatedBooks[index][field] = value;
                }
                setFoundBooks(updatedBooks);
            };
            
            const handleAddAllBooks = async () => {
                const booksToAdd = foundBooks.filter(book => !book.error);
                if (booksToAdd.length === 0) {
                    setError('No valid books to add.');
                    return;
                }

                try {
                    const batch = writeBatch(db);
                    let baseOrderIndex = Date.now();
                    booksToAdd.forEach((book, index) => {
                        const readDate = new Date(book.readYear, book.readMonth, 15).toISOString().split('T')[0];
                        const newBookRef = doc(collection(db, "readings"));
                        batch.set(newBookRef, {
                            ...book,
                            readDate,
                            readYear: book.readYear,
                            userId: auth.currentUser.uid,
                            orderIndex: baseOrderIndex + index, // Assign sequential order
                        });
                    });
                    await batch.commit();
                    onBooksAdded();
                } catch (err) {
                    setError('Failed to save books to your library.');
                }
            };

            return (
                <div className="max-w-4xl mx-auto p-6 bg-gray-800 rounded-lg">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-xl font-bold">Add Multiple Books</h2>
                        <button onClick={onCancel} className="text-gray-400 hover:text-white">&times;</button>
                    </div>
                    <form onSubmit={handleFindBooks} className="mb-4">
                        <textarea
                            value={isbnList}
                            onChange={(e) => setIsbnList(e.target.value)}
                            onPaste={handlePaste}
                            placeholder="Paste a list of ISBNs, separated by spaces or commas"
                            className="w-full h-24 p-2 bg-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        />
                        <button type="submit" disabled={loading} className="mt-2 w-full px-4 py-2 font-bold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 disabled:bg-gray-500">
                            {loading ? 'Searching...' : 'Find Books'}
                        </button>
                    </form>
                    {error && <p className="text-red-400 mb-4">{error}</p>}

                    {foundBooks.length > 0 && (
                        <div className="space-y-4">
                            {foundBooks.map((book, index) => (
                                <div key={book.isbn} className="p-4 bg-gray-700 rounded-md">
                                    {book.error ? (
                                        <p className="text-red-400">ISBN: {book.isbn} - Not Found</p>
                                    ) : (
                                        <div className="grid grid-cols-1 md:grid-cols-4 gap-4 items-start">
                                            <div className="md:col-span-1">
                                                <img src={book.coverUrl} alt={book.title} className="w-24 h-36 object-cover rounded-md" />
                                            </div>
                                            <div className="md:col-span-3 grid grid-cols-1 sm:grid-cols-2 gap-4">
                                                <div>
                                                    <p className="font-bold">{book.title}</p>
                                                    <p className="text-sm text-gray-400">{book.author}</p>
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Date Read</label>
                                                    <div className="flex gap-2 mt-1">
                                                        <select value={book.readMonth} onChange={e => handleBookDataChange(index, 'readMonth', parseInt(e.target.value))} className="w-full p-2 bg-gray-600 rounded-md text-sm text-white">
                                                            {['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'].map((m, i) => <option key={i} value={i}>{m}</option>)}
                                                        </select>
                                                        <input type="number" value={book.readYear} onChange={e => handleBookDataChange(index, 'readYear', parseInt(e.target.value))} className="w-full p-2 bg-gray-600 rounded-md text-sm text-white" />
                                                    </div>
                                                </div>
                                                <div className="grid grid-cols-2 gap-2">
                                                     <div>
                                                        <label className="block text-xs font-medium text-gray-400">Type</label>
                                                        <select value={book.isFiction} onChange={e => handleBookDataChange(index, 'isFiction', e.target.value === 'true')} className="w-full p-2 mt-1 bg-gray-600 rounded-md text-sm text-white">
                                                            <option value="true">Fiction</option>
                                                            <option value="false">Non-Fiction</option>
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs font-medium text-gray-400">Pages</label>
                                                        <input type="number" value={book.pageCount} onChange={e => handleBookDataChange(index, 'pageCount', parseInt(e.target.value))} className="w-full p-2 mt-1 bg-gray-600 rounded-md text-sm text-white"/>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Genre</label>
                                                    <select name="genreSelect" value={book.isAddingNewGenre ? 'add-new' : book.genre} onChange={e => handleBookDataChange(index, 'genreSelect', e.target.value)} className="w-full p-2 mt-1 bg-gray-600 rounded-md text-white">
                                                        <option value={book.genre} disabled>{book.genre}</option>
                                                        {(book.isFiction ? fictionGenres : nonFictionGenres).map(g => <option key={g} value={g}>{g}</option>)}
                                                        <option value="add-new">--- Add New Genre ---</option>
                                                    </select>
                                                    {book.isAddingNewGenre && (
                                                        <input type="text" placeholder="New Genre" value={book.genre} onChange={e => handleBookDataChange(index, 'genre', e.target.value)} className="w-full p-2 mt-2 bg-gray-500 rounded-md text-white"/>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            ))}
                             <button onClick={handleAddAllBooks} className="mt-4 w-full py-3 font-bold text-white bg-green-600 rounded-md hover:bg-green-700">Add All to Library</button>
                        </div>
                    )}
                </div>
            );
        }

        // --- Stats Component ---
        function Stats({ books, loading }) {
            const [year, setYear] = useState('All Time');
            
            const availableYears = useMemo(() => {
                const years = new Set(books.map(b => b.readYear));
                const currentYear = new Date().getFullYear();
                for (let y = currentYear; y >= 2014; y--) {
                    years.add(y);
                }
                return ['All Time', ...Array.from(years).sort((a, b) => b - a)];
            }, [books]);

            const stats = useMemo(() => {
                const filteredBooks = year === 'All Time' ? books : books.filter(b => b.readYear === year);
                if (filteredBooks.length === 0) return null;

                const booksWithPages = filteredBooks.filter(b => b.pageCount > 0);
                const totalPagesRead = filteredBooks.reduce((acc, book) => acc + Number(book.pageCount || 0), 0);
                const averagePageCount = booksWithPages.length > 0 ? Math.round(totalPagesRead / booksWithPages.length) : 0;
                const shortestBook = booksWithPages.length > 0 ? [...booksWithPages].sort((a, b) => a.pageCount - b.pageCount)[0] : null;
                const longestBook = booksWithPages.length > 0 ? [...booksWithPages].sort((a, b) => b.pageCount - a.pageCount)[0] : null;

                const fictionCount = filteredBooks.filter(b => b.isFiction).length;
                const nonfictionCount = filteredBooks.length - fictionCount;

                const fictionGenreCounts = filteredBooks
                    .filter(b => b.isFiction)
                    .reduce((acc, book) => {
                        if (book.genre) acc[book.genre] = (acc[book.genre] || 0) + 1;
                        return acc;
                    }, {});
                
                const nonFictionGenreCounts = filteredBooks
                    .filter(b => !b.isFiction)
                    .reduce((acc, book) => {
                        if (book.genre) acc[book.genre] = (acc[book.genre] || 0) + 1;
                        return acc;
                    }, {});

                const authorCounts = filteredBooks.reduce((acc, book) => {
                    acc[book.author] = (acc[book.author] || 0) + 1;
                    return acc;
                }, {});
                const mostReadAuthor = Object.entries(authorCounts).sort((a, b) => b[1] - a[1])[0];
                const uniqueAuthors = new Set(filteredBooks.map(b => b.author)).size;

                const monthlyCounts = Array(12).fill(0);
                const pagesPerMonth = Array(12).fill(0);
                if (year !== 'All Time') {
                    filteredBooks.forEach(book => {
                        const month = new Date(book.readDate).getMonth();
                        monthlyCounts[month]++;
                        pagesPerMonth[month] += Number(book.pageCount || 0);
                    });
                }
                
                const booksByDecade = filteredBooks.reduce((acc, book) => {
                    if (book.publicationYear) {
                        const decade = Math.floor(book.publicationYear / 10) * 10;
                        acc[decade] = (acc[decade] || 0) + 1;
                    }
                    return acc;
                }, {});
                
                const booksByCountry = filteredBooks.reduce((acc, book) => {
                    if (book.country) {
                        acc[book.country] = (acc[book.country] || 0) + 1;
                    }
                    return acc;
                }, {});


                return {
                    total: filteredBooks.length, totalPagesRead, fictionCount, nonfictionCount, fictionGenreCounts, nonFictionGenreCounts,
                    mostReadAuthor: mostReadAuthor ? `${mostReadAuthor[0]} (${mostReadAuthor[1]} books)` : 'N/A',
                    monthlyCounts, pagesPerMonth, averagePageCount, shortestBook, longestBook, uniqueAuthors, booksByDecade, booksByCountry
                };
            }, [year, books]);

            useEffect(() => {
                let pieChart, fictionGenreChart, nonFictionGenreChart, lineChart, decadeChart, countryChart;
                const chartInstances = [];

                if (stats) {
                    const pieCtx = document.getElementById('pie-chart')?.getContext('2d');
                    if (pieCtx) {
                        pieChart = new Chart(pieCtx, {
                            type: 'pie',
                            data: {
                                labels: ['Fiction', 'Non-Fiction'],
                                datasets: [{ data: [stats.fictionCount, stats.nonfictionCount], backgroundColor: ['#818cf8', '#f87171'], borderColor: '#1f2937' }]
                            },
                            options: { plugins: { legend: { labels: { color: 'white' }}}}
                        });
                        chartInstances.push(pieChart);
                    }

                    const fictionCtx = document.getElementById('fiction-genre-chart')?.getContext('2d');
                    if (fictionCtx && Object.keys(stats.fictionGenreCounts).length > 0) {
                        const sortedGenres = Object.entries(stats.fictionGenreCounts).sort((a, b) => b[1] - a[1]);
                        fictionGenreChart = new Chart(fictionCtx, {
                            type: 'bar',
                            data: {
                                labels: sortedGenres.map(item => item[0]),
                                datasets: [{ label: 'Books per Genre', data: sortedGenres.map(item => item[1]), backgroundColor: '#818cf8' }]
                            },
                            options: { scales: { y: { ticks: { color: 'white', stepSize: 1 }, grid: { color: '#4b5563' } }, x: { ticks: { color: 'white' } } }, plugins: { legend: { display: false }} }
                        });
                        chartInstances.push(fictionGenreChart);
                    }

                    const nonfictionCtx = document.getElementById('nonfiction-genre-chart')?.getContext('2d');
                    if (nonfictionCtx && Object.keys(stats.nonFictionGenreCounts).length > 0) {
                        const sortedGenres = Object.entries(stats.nonFictionGenreCounts).sort((a, b) => b[1] - a[1]);
                        nonFictionGenreChart = new Chart(nonfictionCtx, {
                            type: 'bar',
                            data: {
                                labels: sortedGenres.map(item => item[0]),
                                datasets: [{ label: 'Books per Genre', data: sortedGenres.map(item => item[1]), backgroundColor: '#f87171' }]
                            },
                            options: { scales: { y: { ticks: { color: 'white', stepSize: 1 }, grid: { color: '#4b5563' } }, x: { ticks: { color: 'white' } } }, plugins: { legend: { display: false }} }
                        });
                        chartInstances.push(nonFictionGenreChart);
                    }
                    
                    if (year !== 'All Time') {
                        const lineCtx = document.getElementById('line-chart')?.getContext('2d');
                        if(lineCtx) {
                            lineChart = new Chart(lineCtx, {
                                type: 'line',
                                data: {
                                    labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                                    datasets: [{ label: 'Pages Read per Month', data: stats.pagesPerMonth, borderColor: '#818cf8', tension: 0.1 }]
                                },
                                options: { scales: { y: { ticks: { color: 'white' }, grid: { color: '#4b5563' } }, x: { ticks: { color: 'white' } } }, plugins: { legend: { display: false }} }
                            });
                            chartInstances.push(lineChart);
                        }
                    }

                    const decadeCtx = document.getElementById('decade-chart')?.getContext('2d');
                    if (decadeCtx) {
                        const sortedDecades = Object.keys(stats.booksByDecade).sort();
                        decadeChart = new Chart(decadeCtx, {
                            type: 'bar',
                            data: {
                                labels: sortedDecades.map(d => `${d}s`),
                                datasets: [{ label: 'Books by Decade', data: sortedDecades.map(d => stats.booksByDecade[d]), backgroundColor: '#818cf8' }]
                            },
                            options: { scales: { y: { ticks: { color: 'white', stepSize: 1 }, grid: { color: '#4b5563' } }, x: { ticks: { color: 'white' } } }, plugins: { legend: { display: false }} }
                        });
                        chartInstances.push(decadeChart);
                    }
                    
                    const countryCtx = document.getElementById('country-chart')?.getContext('2d');
                    if (countryCtx) {
                        countryChart = new Chart(countryCtx, {
                            type: 'pie',
                            data: {
                                labels: Object.keys(stats.booksByCountry),
                                datasets: [{ data: Object.values(stats.booksByCountry) }]
                            },
                            options: { plugins: { legend: { labels: { color: 'white' }}}}
                        });
                        chartInstances.push(countryChart);
                    }
                }

                return () => {
                    chartInstances.forEach(chart => chart.destroy());
                };
            }, [stats]);


            if (loading) return <p>Loading stats...</p>;

            return (
                <div>
                    <div className="flex items-center gap-4 mb-6">
                        <h2 className="text-2xl font-bold">Statistics for</h2>
                        <select value={year} onChange={e => setYear(e.target.value === 'All Time' ? 'All Time' : Number(e.target.value))} className="p-2 bg-gray-700 rounded-md">
                            {availableYears.map(y => <option key={y} value={y}>{y}</option>)}
                        </select>
                    </div>

                    {!stats ? (
                        <p className="text-gray-400">No books read for this period. Add one to see your stats!</p>
                    ) : (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                            <div className="p-4 bg-gray-800 rounded-lg"><h3 className="font-bold text-lg mb-2">Total Books Read</h3><p className="text-5xl font-bold text-indigo-400">{stats.total}</p></div>
                            <div className="p-4 bg-gray-800 rounded-lg"><h3 className="font-bold text-lg mb-2">Total Pages Read</h3><p className="text-5xl font-bold text-indigo-400">{stats.totalPagesRead.toLocaleString()}</p></div>
                            <div className="p-4 bg-gray-800 rounded-lg"><h3 className="font-bold text-lg mb-2">Avg. Book Length</h3><p className="text-5xl font-bold text-indigo-400">{stats.averagePageCount.toLocaleString()} pgs</p></div>
                            <div className="p-4 bg-gray-800 rounded-lg"><h3 className="font-bold text-lg mb-2">Unique Authors</h3><p className="text-5xl font-bold text-indigo-400">{stats.uniqueAuthors}</p></div>
                            
                            <div className="md:col-span-2 p-4 bg-gray-800 rounded-lg"><h3 className="font-bold text-lg mb-2">Most Read Author</h3><p className="text-3xl font-bold text-indigo-400">{stats.mostReadAuthor}</p></div>
                            <div className="p-4 bg-gray-800 rounded-lg flex gap-4 items-start"><img src={stats.shortestBook?.coverUrl} className="w-20 h-auto object-cover rounded-md flex-shrink-0"/><div className="flex-grow"><h3 className="font-bold text-lg mb-2">Shortest Book</h3><p className="text-xl font-bold text-indigo-400">{stats.shortestBook?.title || 'N/A'}</p><p className="text-sm text-gray-400">{stats.shortestBook?.pageCount} pgs</p></div></div>
                            <div className="p-4 bg-gray-800 rounded-lg flex gap-4 items-start"><img src={stats.longestBook?.coverUrl} className="w-20 h-auto object-cover rounded-md flex-shrink-0"/><div className="flex-grow"><h3 className="font-bold text-lg mb-2">Longest Book</h3><p className="text-xl font-bold text-indigo-400">{stats.longestBook?.title || 'N/A'}</p><p className="text-sm text-gray-400">{stats.longestBook?.pageCount} pgs</p></div></div>
                            
                            <div className="p-4 bg-gray-800 rounded-lg lg:col-span-2"><h3 className="font-bold text-lg mb-2">Fiction vs. Non-Fiction</h3><canvas id="pie-chart"></canvas></div>
                            <div className="p-4 bg-gray-800 rounded-lg lg:col-span-2"><h3 className="font-bold text-lg mb-2">Books by Decade</h3><canvas id="decade-chart"></canvas></div>
                            <div className="p-4 bg-gray-800 rounded-lg md:col-span-2"><h3 className="font-bold text-lg mb-2">Books by Country</h3><canvas id="country-chart"></canvas></div>
                            
                            <div className="p-4 bg-gray-800 rounded-lg md:col-span-2 lg:col-span-2"><h3 className="font-bold text-lg mb-2">Top Fiction Genres</h3><canvas id="fiction-genre-chart"></canvas></div>
                            <div className="p-4 bg-gray-800 rounded-lg md:col-span-2 lg:col-span-2"><h3 className="font-bold text-lg mb-2">Top Non-Fiction Genres</h3><canvas id="nonfiction-genre-chart"></canvas></div>

                            {year !== 'All Time' && (
                                <div className="p-4 bg-gray-800 rounded-lg md:col-span-2 lg:col-span-4">
                                    <h3 className="font-bold text-lg mb-2">Monthly Reading Pace (Pages)</h3>
                                    <canvas id="line-chart"></canvas>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }
        
        // --- Lightbox Component ---
        function Lightbox({ book, onClose }) {
            if (!book) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4" onClick={onClose}>
                    <div className="bg-gray-800 p-6 rounded-lg max-w-lg w-full flex flex-col md:flex-row gap-6" onClick={e => e.stopPropagation()}>
                        <img src={book.coverUrl} alt={book.title} className="w-48 h-auto object-cover rounded-md shadow-lg self-center md:self-start" />
                        <div className="flex flex-col flex-grow">
                            <h2 className="text-2xl font-bold text-white mb-2">{book.title}</h2>
                            <p className="text-lg text-gray-300 mb-4">{book.author}</p>
                            <div className="space-y-2 text-sm">
                                <p><span className="font-bold text-gray-400">Type:</span> {book.isFiction ? 'Fiction' : 'Non-Fiction'}</p>
                                <p><span className="font-bold text-gray-400">Genre:</span> {book.genre}</p>
                                <p><span className="font-bold text-gray-400">Pages:</span> {book.pageCount > 0 ? book.pageCount : 'N/A'}</p>
                                <p><span className="font-bold text-gray-400">Read:</span> {new Date(book.readDate).toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</p>
                            </div>
                            <button onClick={onClose} className="mt-4 md:mt-auto ml-auto px-4 py-2 bg-indigo-600 text-white rounded-md">Close</button>
                        </div>
                    </div>
                </div>
            );
        }

        // --- Books Display (Gallery + List) Component ---
        function BooksDisplay({ books, loading, onBookUpdated }) {
            const [viewMode, setViewMode] = useState('list');
            const [displayedBooks, setDisplayedBooks] = useState([]);
            const [editingBookId, setEditingBookId] = useState(null);
            const [editFormData, setEditFormData] = useState({});
            const [lightboxBook, setLightboxBook] = useState(null);
            const [isEditingNewGenre, setIsEditingNewGenre] = useState(false);
            const [isBulkEditing, setIsBulkEditing] = useState(false);
            const [bulkEditData, setBulkEditData] = useState([]);
            const [selectedPeriod, setSelectedPeriod] = useState(new Date().getFullYear()); // Can be a year (number) or 'All Time' (string)
            
            const draggedItem = useRef(null);
            
            const availablePeriods = useMemo(() => {
                const years = new Set(books.map(b => b.readYear));
                for (let y = new Date().getFullYear(); y >= 2014; y--) years.add(y);
                return ['All Time', ...Array.from(years).sort((a, b) => b - a)];
            }, [books]);
            
            const fictionGenres = useMemo(() => [...new Set(books.filter(b => b.isFiction).map(b => b.genre))], [books]);
            const nonFictionGenres = useMemo(() => [...new Set(books.filter(b => !b.isFiction).map(b => b.genre))], [books]);
            const allCountries = useMemo(() => [...new Set(books.map(b => b.country).filter(Boolean))].sort(), [books]);

            useEffect(() => {
                let filteredBooks;

                // 1. Filter the books based on the selected period
                if (selectedPeriod === 'All Time') {
                    filteredBooks = [...books]; // Use a copy of all books
                } else {
                    filteredBooks = books.filter(b => b.readYear === selectedPeriod);
                }

                // 2. Sort the filtered list
                if (selectedPeriod === 'All Time') {
                    // For "All Time" view, always sort chronologically by the full read date
                    filteredBooks.sort((a, b) => new Date(a.readDate) - new Date(b.readDate));
                }
                // For a single year, we rely on the default sort (by orderIndex) from the main `books` array.

                setDisplayedBooks(filteredBooks);

                if (isBulkEditing && selectedPeriod !== 'All Time') {
                    const dataForEditing = filteredBooks.map(book => {
                        const date = new Date(book.readDate);
                        return { ...book, readMonth: date.getMonth(), readYear: date.getFullYear(), isAddingNewGenre: false, isAddingNewCountry: false };
                    });
                    setBulkEditData(dataForEditing);
                } else if (isBulkEditing && selectedPeriod === 'All Time') {
                    // If user switches to "All Time" during bulk edit, cancel it.
                    setIsBulkEditing(false);
                }
            }, [books, selectedPeriod, isBulkEditing]);
            
            const handlePeriodSelect = (period) => {
                setSelectedPeriod(period);
            };
            
            const deleteBook = async (bookId) => {
                if (window.confirm("Are you sure you want to delete this book?")) {
                    await deleteDoc(doc(db, "readings", bookId));
                    onBookUpdated();
                }
            };
            
            const handleDragStart = (e, index) => {
                draggedItem.current = displayedBooks[index];
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                const draggedOverItem = displayedBooks[index];
                if (draggedItem.current === draggedOverItem) {
                    return;
                }
                let items = displayedBooks.filter(item => item.id !== draggedItem.current.id);
                items.splice(index, 0, draggedItem.current);
                setDisplayedBooks(items);
            };
            
            const handleDrop = async () => {
                const batch = writeBatch(db);
                displayedBooks.forEach((book, index) => {
                    const bookRef = doc(db, "readings", book.id);
                    batch.update(bookRef, { orderIndex: index });
                });
                await batch.commit();
                draggedItem.current = null;
                onBookUpdated();
            };

            const handleEditClick = (book) => {
                setEditingBookId(book.id);
                const date = new Date(book.readDate);
                setEditFormData({
                    title: book.title,
                    coverUrl: book.coverUrl,
                    readMonth: date.getMonth(),
                    readYear: date.getFullYear(),
                    pageCount: book.pageCount || 0,
                    genre: book.genre,
                    country: book.country || '',
                    isFiction: book.isFiction,
                });
            };

            const handleCancelEdit = () => {
                setEditingBookId(null);
                setIsEditingNewGenre(false);
            };

            const handleSaveEdit = async (bookId) => {
                const { readMonth, readYear, pageCount, genre, title, coverUrl, country } = editFormData;
                const newReadDate = new Date(readYear, readMonth, 15).toISOString().split('T')[0];
                const updatedData = {
                    readDate: newReadDate,
                    pageCount: Number(pageCount),
                    genre,
                    title,
                    coverUrl,
                    country,
                    readYear: Number(readYear),
                };
                const bookRef = doc(db, "readings", bookId);
                await updateDoc(bookRef, updatedData);
                setEditingBookId(null);
                setIsEditingNewGenre(false);
                onBookUpdated();
            };

            const handleEditFormChange = (e) => {
                const { name, value } = e.target;
                if (name === 'genreSelect') {
                    if (value === 'add-new') {
                        setIsEditingNewGenre(true);
                        setEditFormData(prev => ({ ...prev, genre: '' }));
                    } else {
                        setIsEditingNewGenre(false);
                        setEditFormData(prev => ({ ...prev, genre: value }));
                    }
                } else {
                    setEditFormData(prev => ({ ...prev, [name]: value }));
                }
            };

            const toggleBulkEdit = () => {
                if (!isBulkEditing) {
                    const dataForEditing = displayedBooks.map(book => {
                        const date = new Date(book.readDate);
                        return {
                            ...book,
                            readMonth: date.getMonth(),
                            readYear: date.getFullYear(),
                            isAddingNewGenre: false,
                            isAddingNewCountry: false,
                        };
                    });
                    setBulkEditData(dataForEditing);
                }
                setIsBulkEditing(!isBulkEditing);
            };

            const handleBulkEditChange = (index, field, value) => {
                const updatedData = [...bulkEditData];
                
                if (field === 'genreSelect') {
                    if (value === 'add-new') {
                        updatedData[index].isAddingNewGenre = true;
                        updatedData[index].genre = '';
                    } else {
                        updatedData[index].isAddingNewGenre = false;
                        updatedData[index].genre = value;
                    }
                } else if (field === 'countrySelect') {
                    if (value === 'add-new') {
                        updatedData[index].isAddingNewCountry = true;
                        updatedData[index].country = '';
                    } else {
                        updatedData[index].isAddingNewCountry = false;
                        updatedData[index].country = value;
                    }
                } else if (field === 'isFiction') {
                    const isFiction = value === 'true';
                    updatedData[index].isFiction = isFiction;
                    const newGenreList = isFiction ? fictionGenres : nonFictionGenres;
                    if (!newGenreList.includes(updatedData[index].genre)) {
                        updatedData[index].genre = ''; 
                    }
                }
                else {
                    updatedData[index][field] = value;
                }
                
                setBulkEditData(updatedData);
            };

            const handleSaveBulkEdit = async () => {
                const batch = writeBatch(db);
                bulkEditData.forEach(book => {
                    const bookRef = doc(db, "readings", book.id);
                    const newReadDate = new Date(book.readYear, book.readMonth, 15).toISOString().split('T')[0];
                    const { id, readMonth, isAddingNewGenre, isAddingNewCountry, ...dataToSave } = book;
                    const updatedData = {
                        ...dataToSave,
                        pageCount: Number(book.pageCount),
                        readDate: newReadDate,
                        readYear: Number(book.readYear),
                    };
                    batch.update(bookRef, updatedData);
                });
                await batch.commit();
                setIsBulkEditing(false);
                onBookUpdated();
            };


            if (loading) return <p>Loading books...</p>;
            
            const activeClass = "bg-indigo-600 text-white";
            const inactiveClass = "bg-gray-700 text-gray-300";

            return (
                <div>
                    <Lightbox book={lightboxBook} onClose={() => setLightboxBook(null)} />
                    <div className="flex flex-col md:flex-row justify-between items-center mb-6">
                         <h2 className="text-2xl font-bold mb-2 md:mb-0">Your Library</h2>
                         <div className="flex items-center gap-2">
                              <div className="flex items-center bg-gray-800 p-1 rounded-lg">
                                  <button onClick={() => setViewMode('list')} className={`px-3 py-1 rounded-md text-sm font-medium ${viewMode === 'list' ? activeClass : inactiveClass}`}>List</button>
                                  <button onClick={() => setViewMode('gallery')} className={`px-3 py-1 rounded-md text-sm font-medium ${viewMode === 'gallery' ? activeClass : inactiveClass}`}>Gallery</button>
                              </div>
                              {viewMode === 'list' && !isBulkEditing && selectedPeriod !== 'All Time' && (
                                  <button onClick={toggleBulkEdit} className="px-3 py-1 rounded-md text-sm font-medium bg-yellow-600 text-white">Bulk Edit</button>
                              )}
                         </div>
                    </div>
                    
                    {isBulkEditing && (
                        <div className="flex justify-end gap-2 mb-4">
                            <button onClick={handleSaveBulkEdit} className="px-4 py-2 text-sm font-bold bg-green-600 text-white rounded-md">Save All Changes</button>
                            <button onClick={toggleBulkEdit} className="px-4 py-2 text-sm bg-gray-600 text-white rounded-md">Cancel</button>
                        </div>
                    )}

                    <div className="mb-6">
                        <div className="flex flex-wrap gap-2">
                            {availablePeriods.map(period => (
                                <button
                                    key={period}
                                    onClick={() => handlePeriodSelect(period)}
                                    className={`px-4 py-2 rounded-full text-sm font-medium transition ${selectedPeriod === period ? 'bg-indigo-500 text-white' : 'bg-gray-700 text-gray-300'}`}
                                >
                                    {period}
                                </button>
                            ))}
                        </div>
                    </div>

                    {displayedBooks.length === 0 ? (
                         <p className="text-gray-400">No books found for the selected period.</p>
                    ) : viewMode === 'gallery' ? (
                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-4">
                            {displayedBooks.map(book => (
                                <button key={book.id} onClick={() => setLightboxBook(book)} className="focus:outline-none">
                                    <img 
                                        src={book.coverUrl} 
                                        alt={`Cover of ${book.title}`}
                                        className="w-full h-auto object-cover rounded-md shadow-lg transform hover:scale-105 transition-transform duration-300"
                                    />
                                </button>
                            ))}
                        </div>
                    ) : (
                        <div className="overflow-x-auto">
                            <table className="min-w-full border-separate" style={{ borderSpacing: '0 0.75rem' }}>
                                <thead className="hidden md:table-header-group">
                                    <tr>
                                        <th className="w-[4%] px-3 py-2 text-xs font-bold text-gray-400 uppercase text-center">#</th>
                                        <th className="w-[25%] px-3 py-2 text-xs font-bold text-gray-400 uppercase text-left">Title</th>
                                        <th className="w-[15%] px-3 py-2 text-xs font-bold text-gray-400 uppercase text-left">Author</th>
                                        <th className="w-[10%] px-3 py-2 text-xs font-bold text-gray-400 uppercase text-left">Country</th>
                                        <th className="w-[10%] px-3 py-2 text-xs font-bold text-gray-400 uppercase text-left">Type</th>
                                        <th className="w-[12%] px-3 py-2 text-xs font-bold text-gray-400 uppercase text-left">Genre</th>
                                        <th className="w-[8%] px-3 py-2 text-xs font-bold text-gray-400 uppercase text-left">Month</th>
                                        <th className="w-[6%] px-3 py-2 text-xs font-bold text-gray-400 uppercase text-left">Pages</th>
                                        <th className="w-[10%] px-3 py-2 text-xs font-bold text-gray-400 uppercase text-right">Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                {displayedBooks.map((book, index) => {
                                    const isEditing = editingBookId === book.id;
                                    return isBulkEditing ? (
                                        <tr key={book.id}><td colSpan="9" className="p-0"><div className="p-3 bg-gray-700 rounded-lg space-y-3">
                                            <div className="grid grid-cols-1 md:grid-cols-8 gap-4">
                                                <div className="md:col-span-2">
                                                    <label className="block text-xs font-medium text-gray-400">Title</label>
                                                    <input type="text" value={bulkEditData[index]?.title || ''} onChange={(e) => handleBulkEditChange(index, 'title', e.target.value)} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"/>
                                                </div>
                                                <div className="md:col-span-2">
                                                    <label className="block text-xs font-medium text-gray-400">Author</label>
                                                    <input type="text" value={bulkEditData[index]?.author || ''} onChange={(e) => handleBulkEditChange(index, 'author', e.target.value)} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"/>
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Country</label>
                                                    <select
                                                        value={bulkEditData[index]?.isAddingNewCountry ? 'add-new' : bulkEditData[index]?.country}
                                                        onChange={(e) => handleBulkEditChange(index, 'countrySelect', e.target.value)}
                                                        className="w-full p-1 mt-1 bg-gray-600 rounded-md text-sm text-white"
                                                    >
                                                        <option value={bulkEditData[index]?.country} disabled>{bulkEditData[index]?.country || 'Select Country'}</option>
                                                        {allCountries.map(c => <option key={c} value={c}>{c}</option>)}
                                                        <option value="add-new">--- Add New ---</option>
                                                    </select>
                                                    {bulkEditData[index]?.isAddingNewCountry && (
                                                        <input
                                                            type="text"
                                                            placeholder="New Country"
                                                            value={bulkEditData[index]?.country}
                                                            onChange={(e) => handleBulkEditChange(index, 'country', e.target.value)}
                                                            className="w-full p-1 mt-1 bg-gray-500 rounded-md text-white"
                                                        />
                                                    )}
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Type</label>
                                                    <select
                                                        value={bulkEditData[index]?.isFiction}
                                                        onChange={(e) => handleBulkEditChange(index, 'isFiction', e.target.value)}
                                                        className="w-full p-1 mt-1 bg-gray-600 rounded-md text-sm text-white"
                                                    >
                                                        <option value={true}>Fiction</option>
                                                        <option value={false}>Non-Fiction</option>
                                                    </select>
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Genre</label>
                                                    <select
                                                        value={bulkEditData[index]?.isAddingNewGenre ? 'add-new' : bulkEditData[index]?.genre}
                                                        onChange={(e) => handleBulkEditChange(index, 'genreSelect', e.target.value)}
                                                        className="w-full p-1 mt-1 bg-gray-600 rounded-md text-sm text-white"
                                                    >
                                                        <option value={bulkEditData[index]?.genre} disabled>{bulkEditData[index]?.genre || 'Select Genre'}</option>
                                                        {(bulkEditData[index]?.isFiction ? fictionGenres : nonFictionGenres).map(g => <option key={g} value={g}>{g}</option>)}
                                                        <option value="add-new">--- Add New ---</option>
                                                    </select>
                                                    {bulkEditData[index]?.isAddingNewGenre && (
                                                        <input
                                                            type="text"
                                                            placeholder="New Genre"
                                                            value={bulkEditData[index]?.genre}
                                                            onChange={(e) => handleBulkEditChange(index, 'genre', e.target.value)}
                                                            className="w-full p-1 mt-1 bg-gray-500 rounded-md text-white"
                                                        />
                                                    )}
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Date Read</label>
                                                    <div className="flex gap-1 mt-1">
                                                        <select
                                                            value={bulkEditData[index]?.readMonth ?? 0}
                                                            onChange={(e) => handleBulkEditChange(index, 'readMonth', parseInt(e.target.value))}
                                                            className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"
                                                        >
                                                            {['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'].map((m, i) => <option key={i} value={i}>{m}</option>)}
                                                        </select>
                                                        <input
                                                            type="number"
                                                            value={bulkEditData[index]?.readYear ?? new Date().getFullYear()}
                                                            onChange={(e) => handleBulkEditChange(index, 'readYear', parseInt(e.target.value))}
                                                            className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"
                                                        />
                                                    </div>
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Pages</label>
                                                    <input type="number" value={bulkEditData[index]?.pageCount || 0} onChange={(e) => handleBulkEditChange(index, 'pageCount', e.target.value)} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"/>
                                                </div>
                                            </div>
                                        </div></td></tr>
                                    ) : isEditing ? (
                                        <tr key={book.id}><td colSpan="9" className="p-0"><div className="p-3 bg-indigo-900 rounded-lg space-y-3">
                                            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Title</label>
                                                    <input type="text" name="title" value={editFormData.title} onChange={handleEditFormChange} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"/>
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Country</label>
                                                    <input type="text" name="country" value={editFormData.country} onChange={handleEditFormChange} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"/>
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Genre</label>
                                                    <select name="genreSelect" value={isEditingNewGenre ? 'add-new' : editFormData.genre} onChange={handleEditFormChange} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white">
                                                        <option value={editFormData.genre} disabled>{editFormData.genre}</option>
                                                        {(editFormData.isFiction ? fictionGenres : nonFictionGenres).map(g => <option key={g} value={g}>{g}</option>)}
                                                        <option value="add-new">--- Add New Genre ---</option>
                                                    </select>
                                                    {isEditingNewGenre && (
                                                        <input type="text" name="genre" placeholder="New Genre" value={editFormData.genre} onChange={handleEditFormChange} className="w-full p-1 mt-1 bg-gray-500 rounded-md text-white"/>
                                                    )}
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Date Read</label>
                                                    <div className="flex gap-1">
                                                        <select name="readMonth" value={editFormData.readMonth} onChange={handleEditFormChange} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white">
                                                            {['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'].map((m, i) => <option key={i} value={i}>{m}</option>)}
                                                        </select>
                                                        <input type="number" name="readYear" value={editFormData.readYear} onChange={handleEditFormChange} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"/>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-400">Pages</label>
                                                    <input type="number" name="pageCount" value={editFormData.pageCount} onChange={handleEditFormChange} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"/>
                                                </div>
                                            </div>
                                            <div>
                                                <label className="block text-xs font-medium text-gray-400">Cover Image URL</label>
                                                <input type="text" name="coverUrl" value={editFormData.coverUrl} onChange={handleEditFormChange} className="w-full p-1 bg-gray-600 rounded-md text-sm text-white"/>
                                            </div>
                                            <div className="flex justify-end gap-2">
                                                <button onClick={() => handleSaveEdit(book.id)} className="px-3 py-1 text-xs rounded bg-green-600 text-white">Save</button>
                                                <button onClick={handleCancelEdit} className="px-3 py-1 text-xs rounded bg-gray-600 text-white">Cancel</button>
                                            </div>
                                        </div></td></tr>
                                    ) : (
                                        <tr 
                                            key={book.id} 
                                            className="bg-gray-800 cursor-grab"
                                            draggable={selectedPeriod !== 'All Time'}
                                            onDragStart={(e) => handleDragStart(e, index)}
                                            onDragOver={(e) => handleDragOver(e, index)}
                                            onDrop={handleDrop}
                                        >
                                            <td className="p-3 text-center font-bold text-gray-400 rounded-l-lg">{index + 1}</td>
                                            <td className="p-3 flex items-center gap-4">
                                                <img src={book.coverUrl} alt={book.title} className="w-10 h-16 object-cover rounded-md flex-shrink-0 hidden md:block"/>
                                                <span className="font-bold text-white">{book.title}</span>
                                            </td>
                                            <td className="p-3 text-sm text-gray-400">{book.author}</td>
                                            <td className="p-3 text-sm text-gray-400">{book.country || 'N/A'}</td>
                                            <td className="p-3 text-sm text-gray-400">{book.isFiction ? 'Fiction' : 'Non-Fiction'}</td>
                                            <td className="p-3 text-sm text-gray-400">{book.genre}</td>
                                            <td className="p-3 text-sm text-gray-400">{new Date(book.readDate).toLocaleDateString('en-US', { month: 'short' })}</td>
                                            <td className="p-3 text-sm text-gray-400">{book.pageCount > 0 ? book.pageCount : 'N/A'}</td>
                                            <td className="p-3 text-right rounded-r-lg">
                                                <div className="flex justify-end gap-2">
                                                    <button onClick={() => handleEditClick(book)} className="p-1 rounded-md hover:bg-gray-700" title="Edit">
                                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.5L14.732 3.732z" /></svg>
                                                    </button>
                                                    <button onClick={() => deleteBook(book.id)} className="p-1 rounded-md hover:bg-gray-700" title="Delete">
                                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                                                    </button>
                                                </div>
                                            </td>
                                        </tr>
                                    )
                                })}
                                </tbody>
                            </table>
                        </div>
                    )}
                </div>
            );
        }

        // --- Search Component ---
        function Search({ books, onCancel }) {
            const [searchTerm, setSearchTerm] = useState('');
            const [searchType, setSearchType] = useState('title'); // 'title' or 'author'
            const [results, setResults] = useState([]);
            const [hasSearched, setHasSearched] = useState(false);

            const handleSearch = (e) => {
                e.preventDefault();
                if (!searchTerm.trim()) return;

                const lowerCaseSearchTerm = searchTerm.toLowerCase();
                const searchResults = books.filter(book => {
                    if (searchType === 'title') {
                        return book.title.toLowerCase().includes(lowerCaseSearchTerm);
                    } else { // author
                        return book.author.toLowerCase().includes(lowerCaseSearchTerm);
                    }
                });
                setResults(searchResults);
                setHasSearched(true);
            };

            return (
                <div className="max-w-4xl mx-auto p-6 bg-gray-800 rounded-lg">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-xl font-bold">Search Your Library</h2>
                        <button onClick={onCancel} className="text-gray-400 hover:text-white">&times;</button>
                    </div>
                    <form onSubmit={handleSearch} className="flex flex-col sm:flex-row gap-2 mb-6">
                        <input
                            type="text"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            placeholder={`Search by ${searchType}...`}
                            className="flex-grow p-2 bg-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        />
                        <select value={searchType} onChange={(e) => setSearchType(e.target.value)} className="p-2 bg-gray-700 rounded-md text-white">
                            <option value="title">Title</option>
                            <option value="author">Author</option>
                        </select>
                        <button type="submit" className="px-4 py-2 font-bold text-white bg-indigo-600 rounded-md hover:bg-indigo-700">
                            Search
                        </button>
                    </form>

                    <div>
                        {hasSearched && results.length > 0 && (
                            <div className="space-y-3">
                                {results.map(book => (
                                    <div key={book.id} className="flex items-center gap-4 p-3 bg-gray-700 rounded-lg">
                                        <img src={book.coverUrl} alt={book.title} className="w-10 h-16 object-cover rounded-md flex-shrink-0"/>
                                        <div>
                                            <p className="font-bold text-white">{book.title}</p>
                                            <p className="text-sm text-gray-400">{book.author}</p>
                                            <p className="text-xs text-gray-500">Read: {new Date(book.readDate).toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</p>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                        {hasSearched && results.length === 0 && (
                            <p className="text-center text-gray-400">No books found matching your search.</p>
                        )}
                    </div>
                </div>
            );
        }

        // Render the app
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);

    </script>
</body>
</html>
```
